/*
=================================================
Graded Challenge 1

Nama  : Kamelia Ramandha
Batch : CODA-RMT-010

Program ini dibuat untuk melakukan normalisasi pada data dan memahami DDL dan DML
=================================================
*/


-- Membuat kerangka table utama (staging, 0NF)
CREATE TABLE movies_staging (
id VARCHAR(100) PRIMARY KEY,
title VARCHAR(200),
type VARCHAR(50),
description VARCHAR(5000),
release_year INT,
age_certification VARCHAR(50),
runtime INT,
genres TEXT[],
production_countries TEXT[]
);

-- Memasukan data lokal ke table movies_staging
COPY movies_staging ( -- mencopy semua column di bawah dari file lokal di komputer
id,
title,
type,
description,
release_year,
age_certification,
runtime,
genres,
production_countries
)
FROM '/private/tmp/hacktiv8/movies_clean_rev.txt' -- File path dalam tmp
DELIMITER E'\t' -- Delimiternya adalah tab
CSV HEADER; -- File memiliki header

SELECT * FROM movies_staging; -- Mengecek apakah table sudah sesuai

--Membuat kerangka table 1NF
CREATE TABLE movies_1NF ( --membuat kerangka table yang sama dengan fase staging
id VARCHAR(100) PRIMARY KEY,
title VARCHAR(200),
type VARCHAR(50),
description VARCHAR(5000),
release_year INT,
age_certification VARCHAR(50),
runtime INT,
genres TEXT[],
production_countries TEXT[]
);

INSERT INTO movies_1NF ( -- memasukan data ke table baru
  id, title, type, description, release_year,
  age_certification, runtime, genres, production_countries
)
SELECT
  id, title, type, description, release_year,
  age_certification, runtime, genres, production_countries
FROM movies_staging; -- mengambil data untuk table baru dari table staging dikarenakan isi table masih akan sama persis

SELECT * FROM movies_1NF;


-- Menormaliasikan table baru menjadi 1NF dengan memisahkan kolumn Genres

--- Membuat table genre_list untuk membuat dictionary nama dan id genre
CREATE TABLE genre_list( --membuat kerangka table dictionary untuk genre
genre VARCHAR(100),
id_genre SERIAL PRIMARY KEY) -- id akan autogenerated karena menggunakan serial
;

INSERT INTO genre_list (genre) --memasukan data genre
SELECT DISTINCT UNNEST(genres) AS genre --mengambil data unik genre dari array genre
FROM movies_1NF;

SELECT * FROM genre_list; -- melihat bentuk dan hasil dari dictionary genre


--- memisahkan table genre_id dari table movies_1NF
CREATE TABLE genre_id ( -- membuat table bridging untuk table utama dan dictionary genre
id VARCHAR(100) REFERENCES movies_1NF(id), -- id pada table ini akan merefer dari table utama
genres VARCHAR(100),
id_genre INTEGER REFERENCES genre_list(id_genre); -- id_genre table ini akan merefer dari dictionary
);

SELECT * FROM genre_id; -- melihat kerangka table bridging genre

INSERT INTO genre_id (id, genres) --memasukan data ke table bridging genre
SELECT movies_1NF.id, genre
FROM movies_1NF -- mengambil data id dan genre dari table utama
CROSS JOIN LATERAL UNNEST(movies_1nf.genres) as genre; -- memisahkan genre dari array menjadi rows

UPDATE genre_id -- mengupdate isi table bridging genre dengan id_genre di table dictionary genre
SET id_genre = genre_list.id_genre -- mendefinisikan bahwa id_genre pada table bridging akan berasal dari id_genre di table dictionary genre
FROM genre_list
WHERE genre_id.genres = genre_list.genre; -- mendefinisikan Primary & Functional key yang menghubungkan kedua table

ALTER TABLE genre_id
DROP COLUMN genres; -- menghapus column genres pada table bridging untuk membuat data lebih simple

ALTER TABLE movies_1nf
DROP COLUMN genres; -- menghapus column genres pada table utama untuk mengurangi redudansi

SELECT * FROM movies_1nf; -- mengecek kesesuaian table utama


--Memisahkan column production_countries

CREATE TABLE countries_list( -- membuat table dictionary countries
country VARCHAR(100),
id_countries SERIAL PRIMARY KEY) -- id_countries akan autogenerated karena menggunakan SERIAL; menetapkan id_countries sebagai primary key
;

INSERT INTO countries_list (country) --memasukan data ke dictionary countries
SELECT DISTINCT UNNEST(production_countries) AS country -- mengambil data countries yang unik dari table utama
FROM movies_1NF;

SELECT * FROM countries_list; -- melihat hasil dari table dictionary countries

--- memisahkan table countries_id dari table movies_1NF
CREATE TABLE countries_id ( -- membuat table bridging dictionary dan table utama
id VARCHAR(100) REFERENCES movies_1NF(id), -- menyambungkan id pada table bridging dengan id pada table utama
country VARCHAR(100),
id_countries INTEGER REFERENCES countries_list(id_countries) -- menyambungkan id_countries pada table bridging dan id_countries pada table utama
);

INSERT INTO countries_id (id, country) -- memasukkan data id dan country pada table bridging countries
SELECT movies_1NF.id, countries -- mengambil data terseubt dari table utama
FROM movies_1NF
CROSS JOIN LATERAL UNNEST(movies_1nf.production_countries) as countries; -- menggabungkan table dan hanya mengambil countries yang sifatnya unik

UPDATE countries_id --mengupdate column countries_id pada table bridging countries
SET id_countries = countries_list.id_countries -- menetapkan bahwa id_countries pada table bridging akan diambil dari id_countries dari table dictionary countries
FROM countries_list
WHERE countries_id.country = countries_list.country; -- mendefinisikan Primary & Functional key yang menghubungkan kedua table

SELECT * FROM countries_id

ALTER TABLE countries_id -- menghapus column country pada table bridging untuk menyederhanakan data
DROP COLUMN country;

ALTER TABLE movies_1nf -- menghapus column production_countries pada table utama untuk mengurangi redudansi
DROP COLUMN production_countries;

SELECT * FROM movies_1nf; -- mengecek kesesuaian table utama

---- Normalisasi 1NF telah selesai dilakukan, tidak ada lagi cell yang mengandung >1 data
---- Sudah juga memenuhi syarat 2NF dan 3NF karena semua column sudah bergantung kepada Primary Key
---- Maka normalisasi selesai pada tahap ini

-- Pengujian Database
---Menampilkan Semua Film dengan Genre dan Negara Produksinya
SELECT 
    movies_1NF.id, -- menampilkan id yang terletak pada table utama
    movies_1NF.title, -- menampilkan title yang terletak pada table utama
    genre_list.genre, -- menampilkan genre yang terletak pada table dictionary genre
    countries_list.country -- menampilkan country yang terletak pada table dictionary countries
FROM movies_1NF
LEFT JOIN genre_id ON movies_1NF.id = genre_id.id -- menghubungkan data antara table utama dan table bridging genre
LEFT JOIN genre_list ON genre_id.id_genre = genre_list.id_genre -- menghubungkan data antara table bridging genre dengan table dictionary genre
LEFT JOIN countries_id ON movies_1NF.id = countries_id.id -- menghubungkan data antara table utama dan table bridging countries
LEFT JOIN countries_list ON countries_id.id_countries = countries_list.id_countries; -- menghubungkan data antara table bridging countries dengan table dictionary countries

---Genre Film Paling Populer
SELECT genre_list.genre,
	COUNT(DISTINCT movies_1NF.id) AS total_movies -- menghitung jumlah id yang unik pada table utama
FROM movies_1NF
JOIN genre_id ON movies_1NF.id=genre_id.id -- menghubungkan data antara table utama dan table bridging genre
JOIN genre_list ON genre_id.id_genre=genre_list.id_genre -- menghubungkan data antara table bridging genre dengan table dictionary genre
GROUP BY genre_list.genre -- mengelompokan data berdasarkan genre yang ada pada table dictionary genre
ORDER BY total_movies DESC -- mengurutkan data berdasarkan jumlah terbesar dari total_movies
LIMIT 1; -- melimitasi data untuk hanya keluar 1 data

---Negara Paling Banyak Membuat Film
SELECT countries_list.country,
	COUNT(DISTINCT movies_1NF.id) as total_movies -- menghitung jumlah id yang unik pada table utama
FROM movies_1NF
JOIN countries_id ON movies_1NF.id=countries_id.id -- menghubungkan data antara table utama dan table bridging countries
JOIN countries_list ON countries_id.id_countries=countries_list.id_countries -- menghubungkan data antara table bridging countries dengan table dictionary countries
GROUP BY countries_list.country -- mengelompokan data berdasarkan negara pada dictionary countries
ORDER BY total_movies DESC -- mengurutkan data berdasarkan jumlah terbesar dari total_movies
LIMIT 1; -- melimitasi data untuk hanya keluar 1 data


/*
=================================================
SELESAI
=================================================
*/


